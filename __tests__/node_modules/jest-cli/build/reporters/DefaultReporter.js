/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */
'use strict';




const BaseReporter = require('./BaseReporter');

const chalk = require('chalk');
const formatFailureMessage = require('jest-util').formatFailureMessage;
const path = require('path');

// Explicitly reset for these messages since they can get written out in the
// middle of error logging
const FAIL = chalk.reset.bold.bgRed(' FAIL ');
const PASS = chalk.reset.bold.bgGreen(' PASS ');

const LONG_TEST_COLOR = chalk.reset.bold.bgRed;
const RUNNING_TEST_COLOR = chalk.bold.gray;
const TEST_NAME_COLOR = chalk.bold;

const pluralize = (word, count) => `${ count } ${ word }${ count === 1 ? '' : 's' }`;

class DefaultReporter extends BaseReporter {
  onRunStart(config, results) {
    this._printWaitingOn(results, config);}


  onTestResult(
  config, 
  testResult, 
  results) 
  {
    this._clearWaitingOn(config);
    this._printTestFileHeaderAndFailures(config, testResult);
    this._printWaitingOn(results, config);}


  // print one line aggregated info for the test file
  _printTestFileHeaderAndFailures(config, testResult) {
    const pathStr = config.rootDir ? 
    path.relative(config.rootDir, testResult.testFilePath) : 
    testResult.testFilePath;
    const allTestsPassed = testResult.numFailingTests === 0;
    const runTime = testResult.perfStats ? 
    (testResult.perfStats.end - testResult.perfStats.start) / 1000 : 
    null;

    const testDetail = [];
    if (runTime !== null) {
      testDetail.push(
      runTime > 5 ? LONG_TEST_COLOR(runTime + 's') : runTime + 's');}



    if (testResult.memoryUsage) {
      const toMB = bytes => Math.floor(bytes / 1024 / 1024);
      testDetail.push(`${ toMB(testResult.memoryUsage) } MB heap size`);}


    const resultHeader = 
    `${ allTestsPassed ? PASS : FAIL } ${ TEST_NAME_COLOR(pathStr) }` + (
    testDetail.length ? ` (${ testDetail.join(', ') })` : '');

    this.log(resultHeader);

    if (!allTestsPassed) {
      const failureMessage = formatFailureMessage(testResult, { 
        noStackTrace: config.noStackTrace, 
        rootDir: config.rootDir, 
        verbose: config.verbose });


      this._write(failureMessage);
      // This is bad because it's modifiying something it doesn't own.
      // We need to rewrite this whenever we work on config+test result data
      testResult.message = resultHeader + '\n' + failureMessage + '\n';}}



  _clearWaitingOn(config) {
    process.stderr.write(config.noHighlight ? '' : '\r\x1B[K');}


  _printWaitingOn(results, config) {
    const remaining = results.numTotalTestSuites - 
    results.numPassedTestSuites - 
    results.numFailedTestSuites - 
    results.numRuntimeErrorTestSuites;
    if (!config.noHighlight && remaining > 0) {
      process.stderr.write(RUNNING_TEST_COLOR(
      `Running ${ pluralize('test suite', remaining) }...`));}}}





module.exports = DefaultReporter;